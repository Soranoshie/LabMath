# Лабораторная работа: Архиваторы

## Описание проекта
Данная лабораторная работа посвящена теме сжатия данных и реализует алгоритм RLE (Run-Length Encoding). Это один из простых и эффективных методов сжатия данных без потерь, особенно подходящий для последовательностей символов с повторяющимися значениями. В рамках проекта осуществляется кодирование и декодирование строки, а также расчет некоторых статистических показателей сжатия.

## Содержание проекта
Проект состоит из следующих основных компонентов:
- **Алгоритм RLE** для кодирования и декодирования строк.
- Скрипты для работы с текстовыми файлами, включая чтение, запись и обработку данных.
- Вычисление математических показателей, таких как:
  - **Энтропия (H max)**
  - **Средняя длина символа (L среднее)**
  - **Коэффициент статистического сжатия (K cc)**

## Структура проекта
- **Program.cs** — точка входа для запуска программы.
- **ArchiverLab** — папка, содержащая класс `ArchiverLab`, реализующий метод `Execute()`, в котором производится сжатие и декомпрессия данных.
- **Indicators.cs** — модуль для расчета математических показателей сжатия.
- **StringOperations.cs** — модуль для операций чтения и записи строк в файлы.
- **RleEncoder.cs** — модуль, содержащий методы для кодирования и декодирования с использованием алгоритма RLE.

## Демонстрация работы
Перед запуском программы создается файл `numbers.txt` в директории `LabMath\bin\Debug\net8.0`, содержащий строку с различными символами. Эта строка используется в качестве исходных данных для выполнения сжатия с помощью алгоритма RLE.
Алгоритм RLE в данной реализации учитывает возможность работы с числами в исходной строке. Для избежания путаницы при декодировании числа в закодированном файле разделяются символом `:`. Это позволяет алгоритму корректно отличать числа, представляющие количество повторений, от самих символов.

### Шаги выполнения программы:
1. **Чтение исходных данных**: Программа считывает строку из файла `numbers.txt`.
2. **Сжатие данных**: Исходная строка сжимается, и результат записывается в файл `encoded.txt`.
3. **Декодирование данных**: Закодированная строка раскодируется, и результат записывается в файл `decoded.txt`.
4. **Вычисление показателей**:
   - **Энтропия (H max)** — показывает максимально возможное количество информации, которое может содержать сообщение. Рассчитывается по формуле: 
     \[
     H_{max} = \log_2(n)
     \]
     где `n` — количество уникальных символов в строке.
   - **Средняя длина символа (L среднее)** — рассчитывается как средняя длина закодированного символа и отображает, сколько в среднем бит приходится на символ:
     \[
     L_{среднее} = \sum_{i=1}^{n} (P(i) \times L(i))
     \]
     где `P(i)` — вероятность появления символа, а `L(i)` — длина кода символа.
   - **Коэффициент статистического сжатия (K cc)** — показывает степень уменьшения количества информации:
     \[
     K_{cc} = \frac{H_{max}}{L_{среднее}}
     \]

### Пример результатов:
После выполнения программы выводится следующая информация:
  - **Entropy (H max): 3,9068905956085187**
  - **Average length (L среднее): 1,88**
  - **Compression coefficient (K cc): 2,078133295536446**

### Объяснение результатов:
- **Энтропия (H max)** в данном примере показывает теоретически максимальное количество информации на символ, которое может содержать строка. Значение `3,91` указывает, что в среднем каждый символ содержит около 3,91 бит информации.
- **Средняя длина символа (L среднее)** равна `1,88`, что означает, что после сжатия каждый символ представлен в среднем 1,88 битами.
- **Коэффициент сжатия (K cc)** равен `2,08`, что указывает на то, что после сжатия информация уменьшилась более чем в два раза по сравнению с максимально возможным уровнем информации. Значение больше 1 подтверждает эффективность сжатия.
